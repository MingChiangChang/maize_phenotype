# -*- coding: utf-8 -*-
"""segmentation_and_alignment.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1skLNtoiEgvmPU56qjd_1HkqWUpuTXann
"""
from pathlib import Path
import glob

from matplotlib import pyplot as plt
from matplotlib.patches import Rectangle
from scipy.signal import find_peaks
import numpy as np
import cv2


"""# Rotate image to level the rows"""

def level_maize_img(image, angle_range=(-10, 10), angle_steps=20,
                    plot=False):
    '''
    Level the maize image by rotating the image and find the
    rotation angle that has the largest std
    '''
    angles = np.linspace(*angle_range, angle_steps)
    std_vals = []
    
    for angle in angles:
        rotated = rotate_image(image, angle)
        std_vals.append(np.std(avg_with_zeros(rotated, axis=1)))    
    
    if plot:
        plt.plot(std_vals)
        plt.show()

    return angles[np.argmax(std_vals)]

def rotate_image(image, angle: float):
    ''' 
    Take an image and rotate with given angle in degrees.
    The positions without image (left blank because of rotation) are
    filled with 0s.

    Taken from stackoverflow..
    '''
    row,col = image.shape
    center = tuple(np.array([row, col])/2)
    rot_mat = cv2.getRotationMatrix2D(center, angle, 1.0)
    new_image = cv2.warpAffine(image, rot_mat, (col, row))
    return new_image

def avg_with_zeros(arr, axis):
    ''' take mean along an axis, but excludes positions with 0'''
    return np.sum(arr, axis=axis)/np.sum(arr != 0, axis=axis)

"""# Finding Blocks of corns"""

def find_blocks(img, axis=0, predicted_block_width=300, height=1, plot=False,
                **kwargs):
    vertical_std = np.std(img, axis=axis)
    normalized_std = normalize(vertical_std)
    
    peaks = find_peaks(-normalized_std,
                       distance=predicted_block_width,
                       height=height, **kwargs)[0]
    if axis == 0:
        peaks = [0, *peaks, img.shape[1]-1]
    else:
        peaks = [0, *peaks, img.shape[0]-1]

    if plot:
        plt.plot(-normalized_std)
        for peak in peaks:
            plt.axvline(peak, ls='dashed', c='r')
        plt.show()
    
    return peaks

def normalize(arr):
    mean = np.mean(arr)
    std = np.std(arr)
    arr = (arr-mean)/std
    return arr

def get_avg_block_width(anchor_pts):
    return anchor_pts[-2]/(len(anchor_pts)-2)

def add_extra_blocks(anchor_pts):
    avg_block_width = get_avg_block_width(anchor_pts)
    while anchor_pts[-1]-anchor_pts[-2] > avg_block_width:
        anchor_pts.insert(-1, anchor_pts[-2]+avg_block_width)
    return anchor_pts

"""# Utilities for plotting"""

def plot_continous_boxes(img_shape, anchor_pts):
    xys = [(0, pt) for pt in anchor_pts]
    widths = [img_shape[1] for _, _ in enumerate(anchor_pts)]
    heights = [anchor_pts[i+1] - anchor_pts[i] for i in range(len(anchor_pts)-1)]
    plot_boxes(xys, widths, heights)

def plot_boxes(xys, widths, heights):
    for xy, width, height in zip(xys, widths, heights):
        plot_box(xy, width, height)

def plot_box(xy, width, height):
    plt.gca().add_patch(Rectangle(xy, width, height, linewidth=2, edgecolor='r',facecolor='none'))

#g = []
#ind = level_maize_img(img[:,:,2], angle_range=(-20, 20), angle_steps=20,
#              plot=True)
#print(ind)
#rotated_image = rotateImage(img[:,:,2], ind)
#plt.imshow(rotated_image)
#plt.show()
#
#peaks = find_blocks(rotated_image, plot=True, height=0.6)
#blocks = []
#for idx, peak in enumerate(peaks):
#    if idx + 1 < len(peaks):
#        blocks.append(rotated_image[:,peaks[idx]:peaks[idx+1]])
#        plt.imshow(rotated_image[:,peaks[idx]:peaks[idx+1]])
#        plt.show()
#
#for idx, block in enumerate(blocks):
#      peaks = find_blocks(block, predicted_block_width=30, axis=1, height=0, plot=True,
#                          prominence=0.3)
#      plt.imshow(block)
#      add_extra_blocks(peaks)
#      print(peaks)
#      plot_continous_boxes(block.shape, peaks)
#      plt.show()

#def find_blocks(img):
#  height, width = img.shape
#  # Compute the sum of pixels along the vertical direction
#  column_sum = np.sum(img, axis=0)
#  max_sum, min_sum = column_sum.max(), column_sum.min()
#  threshold = (max_sum + min_sum)/2
#  # Threshold the pixel sums to find the gaps between crops
#  # Assume that gaps are darker
#  gap_pos = (column_sum<=threshold).astype(int)
#  gap_grad = np.gradient(gap_pos)
#  # Find the edges of the gaps
#  gap_idx = np.where(np.abs(gap_grad)>0)[0]
#  if gap_pos[0]:
#    gap_idx = gap_idx[2:]
#  if gap_pos[width-1]:
#    gap_idx = gap_idx[:-2]
#  left_edges = list(gap_idx[::4])
#  right_edges = list(gap_idx[2:][::4])
#  left_edges.insert(0, 0)
#  right_edges.append(width-1)
#  # Generate boxes by the left and right edges of gaps
#  boxes = [[left_edges[i], right_edges[i]] for i in range(len(left_edges))]
#  return np.array(boxes)

def slice_img(img, bounds):
  left, right = bounds 
  return img[:, left:right+1]
